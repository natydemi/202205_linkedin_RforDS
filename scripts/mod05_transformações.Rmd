---
title: "Transformação e Arrumação de Dados"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, collapse = TRUE)
```

# Bibliotecas

```{r}
library(tidyverse)
```


# Introdução

Uma parte fundamental da análise de dados é o manuseio da informação, o que implica em ser capaz de aplicar transformações, e reformatar a estrutura dos dados. Neste módulo, falaremos sobre tais ações por meio dos pacotes `dplyr` e `tidyr`. O primeiro, `dplyr`, tendo como enfoque a transformação das informações, enquanto o `tidyr` nos possibilita novas estruturas, garantindo dados em uma [estrutura tidy](https://r4ds.had.co.nz/tidy-data.html) – conforme discutido no primeiro módulo do curso.


# Transformando dados com a gramática do dplyr

Na descrição do pacote, o `dplyr` é definido como a gramática para transformação de dados, e esse nome não é à toa. Ele possui vários verbos que definem ações específicas para lidar com bases de dados, visando modificá-las de forma simples e eficiente. Algumas das principais funções do dplyr são:

- `select()` - seleciona colunas;
- `filter()` - filtra linhas a partir de regras lógicas;
- `arrange()` - ordena as linhas da base de dados;
- `mutate()` - cria/modifica colunas;
- `group_by()` - agrupa linhas da base de dados;
- `summarise()` - resume a base de dados em menos linhas.

De modo que em conjunto com o operador pipe – comentado no módulo 1, é possível segmentar o que precisa ser feito com a base de dados em passos, deixando os scripts mais legíveis e organizados.

Por exemplo, se você precisa descobrir **quais voos da companhia American Airlines tiveram o maior tempo de atraso**, é possível separar esta pergunta em etapas:

1. **quais voos da companhia American Airlines**: filtrar voos da AA;

2. **tiveram o maior tempo de atraso**: ordenar pelo tempo de atraso.

Um bom exercício nas etapas de transformação de dados é encaixar os diferentes verbos do dplyr nas diversas perguntas que você precisa responder para analisar o conjunto de dados. Vamos ao exemplo:


```{r}
voos <- dados::voos %>% glimpse()
```



## Manuseando colunas

Aqui, vamos aprender como lidar com as colunas do seu conjunto de dados, seja selecionando ou ordenando a informação.

### `select()`

Como falamos acima, o `select()` seleciona as colunas a partir do nome ou da posição da variável desejada. Junto com as funções de apoio no [tidyselect](https://tidyselect.r-lib.org/reference/index.html), você também consegue indicar a(s) coluna(s) desejada(s) de forma dinâmica, como: `starts_with()`, `matches()`, `num_range()`, `everything()` e `where()`, ou ainda adicionando o simbolo menos `-` antes da coluna que gostaríamos de excluir

```{r}
voos %>% 
  #select(atraso_saida) %>% 
  #select(-atraso_saida) %>% 
  #select(contains("horario")) %>% 
  select(where(is.character)) %>% 
  head()
```


#### `pull()`

Algumas funções do R não aceitam tibbles como entrada (esta que é a estrutura de saída da função `select()`), como alternativa podemos trabalhar com a função `pull()`. Compare:

```{r}
voos %>% select(companhia_aerea) %>% class()
voos %>% select(companhia_aerea) %>% is.vector()
```

```{r}
voos %>% pull(companhia_aerea) %>% class()
voos %>% pull(companhia_aerea) %>% is.vector()
```

Lembrando que quando estamos trabalhando com um vetor atômico, o retorno da função `class()` se limita ao tipo de classe, e não a estrutura em si. 


### `arrange()`

Com `arrange()`, conseguimos ordenar as linhas de acordo com a(s) coluna(s) especificada(s). Por padrão, ele organiza as colunas na ordem crescente, mas é possível inverter para a ordem com a função `desc()`.
    
```{r}
voos %>% 
  select(companhia_aerea, voo, atraso_chegada) %>%
  arrange(-atraso_chegada) %>% 
  head()
```

No exemplo acima, o voo VX 193 chegou com 86 minutos adiantado, uau! E abaixo, o voo HA 51, chegou com 1.272 minutos (ou 21 horas) de atraso. Imagina o desespero dos parentes...

```{r}
voos %>% 
  select(companhia_aerea, voo, atraso_chegada) %>%
  arrange(desc(companhia_aerea)) %>% 
  head()
```

### `relocate()`

Como última função deste bloco, e me vejo obrigada a dizer, uma das funções que mais uso, é a `relocate()`, esta função faz algo simples: muda a coluna de posição. Contudo isto é feito de maneira muito prática:

```{r}
voos%>%
  select(1:3) %>% 
  glimpse() %>% 
  relocate(dia, .before = ano) %>% 
  glimpse() %>% 
  relocate(ano, .after = last_col()) %>% 
  glimpse()
```



## Manuseando linhas

Além das colunas, você também pode fazer transformações nas linhas do conjunto de dados. Os verbos abaixo são bem úteis:

### `filter()`

Como o nome sugere, o `filter()` permite obter uma parte do conjunto de dados a partir de critérios lógicos aplicados à coluna (ou seja, que retornam `TRUE` ou `FALSE`). Você pode combinar diferentes condições usando operadores como: `==`, `>`, `>=`, `&`, `|`, `!,` `is.na()` e `between()`.

Por exemplo, para descobrir os voos que atrasaram na saída (vamos dizer com mais de 15 min de atraso), mas não atrasaram na chegada, é só escrever:

```{r}
voos %>%
  #filter(atraso_saida == 0) %>% 
  #filter(atraso_saida >= 15 & atraso_chegada <= 0) %>%
  #filter(atraso_saida == c(15, 16)) %>% 
  filter(atraso_saida %in% c(15, 16)) %>% 
  select(companhia_aerea, voo, atraso_saida, atraso_chegada)
```

Alguns até chegaram adiantados! :O


> Um ponto importante ao trabalhar com filtros no R, é que para aplicar um filtro para um único valor, utilizamos o operador lógico `==` enquanto que para trabalhar com mais de um valor, precisamos trabalhar com `%in%`. Isto porque no primeiro caso o R faz uma comparação dos elementos da coluna selecionada com os valores que desejamos filtrar de maneira alternada, de modo que alguns casos acabam sendo desconsiderados no filtro. Já com o operador `%in%`, garantimos que todos os elementos da coluna de interesse sejam comparados com todos os elementos que desejamos considerar no filtro. [Neste post do stackoverflow](https://stackoverflow.com/questions/15358006/what-is-the-difference-between-in-and) você encontrará mais detalhes sobre ;)


### `slice()`

Parecido com o `filter()`, o `slice()` seleciona linhas, mas em vez de operadores lógicos, usa suas posições ordinais, como um índice. Neste exemplo, selecionamos os 3 voos com maior atraso de saída: 

```{r}
voos %>%
  slice(1:3) %>% 
  select(companhia_aerea, voo, atraso_saida, atraso_chegada)
```

Esta função possui variações importantes, como:


- `slice_max()` ou `slice_min()` que retorna as linhas referentes aos valores máximos/mínimos da coluna, com base no parâmetro `n` específicado (quantidade de linhas desejadas); 

- `slice_sample()`, que resulta uma amostra aleatória considerando ou o número de elementos desejados (parâmetro `n`), ou a proporção desejada (parâmetro `n`).

- `slice_head()` e `slice_tail()` equivalentes às funções `head()` e `tail()`, tendo, contudo, algumas funcionalidades a mais, como a possibilidade de trabalhar não apenas com a quantidade de linhas desejadas (parâmetro `n`), mas também com a proporção (parâmetro `prop`) – assim como as demais funções do slice
    
```{r}
voos %>% 
  slice_max(atraso_saida, n = 20) %>%
  slice_sample(prop = 0.5) %>% 
  slice_sample(n = 5) %>% 
  slice_head(prop = 0.6)
```


Note que ao trabalhar com amostras, tratam-se de amostras aleatórias, o que significa que a cada vez que você rodar o código, o resultado poderá ser alterado. Para replicar os mesmos resultados, é importante que uma semente seja específicada, compare:

```{r}
voos %>% 
  slice_sample(n = 3) 

voos %>% 
  slice_sample(n = 3) 

set.seed(2)
voos %>% 
  slice_sample(n = 3)

set.seed(2)
voos %>% 
  slice_sample(n = 3) 

```



> Originalmente, para trabalharmos com amostras, tinhamos as funções: `sample_frac()` e `sample_n()`, porém estas foram substituidas pela função `slice_sample()`.


### `distinct()`

Bem útil quando você tem linhas iguais, o `distinct()` remove valores duplicados para as colunas selecionadas. Se você não selecionar nenhuma coluna, ele olha para o conjunto de dados inteiro, mas você pode tanto especificar uma coluna quanto combinar várias.

```{r}
voos %>%
  distinct(companhia_aerea)
```

Neste último caso, ele considera os valores únicos combinados para essas colunas, e não elas individualmente. Neste exemplo, selecionamos as origens para cada companhia aérea.

```{r}
voos %>%
  distinct(companhia_aerea, origem) %>% 
  arrange(companhia_aerea)
```

```{r}
voos %>% nrow() 

voos %>% distinct() %>% nrow() 
```

Sem o `distinct()`, e apenas com o `select()`, teríamos um número maior de linhas, e a maioria, duplicadas.

```{r}
voos %>%
  select(companhia_aerea, origem)
```



## Alterando e criando novas colunas

Agora que aprendemos a ler o conjunto de dados a partir de linhas e colunas, vamos ver como alterar valores ou criar novas colunas a partir do que já conseguimos especificar.

### `mutate()`

Um dos verbos mais poderosos do `dplyr`, o `mutate()` consegue criar novas colunas e modificar variáveis já existentes, inclusive alterando a classe dos dados quando necessário (de texto para número, por exemplo).

```{r}
voos %>% 
  mutate(atraso_saida = as.integer(atraso_saida)) %>% 
  mutate(atraso_saida_index = ifelse(atraso_saida > 0 , TRUE, FALSE)) %>% 
  glimpse()
```


Ele pode ser combinado com outras funções igualmente eficientes como `ifelse()` e `case_when()`, que possibilitam regras mais elaboradas na transformação dos dados.

Por exemplo, podemos categorizar os voos que atrasaram ou chegaram adiantados comparando a chegada com o horário previsto na nova coluna `status_horario`. Veja:
    
```{r}
voos_atrasados <- voos %>% 
  mutate(status_horario = case_when(
    horario_chegada < chegada_prevista ~ "Adiantado",
    horario_chegada > chegada_prevista ~ "Atrasado",
    horario_chegada == chegada_prevista ~ "No horário",
    TRUE ~ "Indefinido"))

voos_atrasados %>%
  select(voo, chegada_prevista, horario_chegada, atraso_chegada, status_horario)
```

Note que o `case_when()` tem uma sintaxe bem específica. Mais detalhes podem ser vistos [na documentação](https://dplyr.tidyverse.org/reference/case_when.html). Em suma, você precisa passar uma expressão lógica e, caso ela seja atendida, o valor a ser escrito após o `~` é atribuído. O último argumento serve para atribuir um valor caso nenhuma condição seja satisfeita.

### `rename()`

Mais simples, mas ainda útil, o `rename()` é capaz de renomear colunas pelo argumento `nome_novo = nome_antigo`. Aqui, renomeamos a coluna `voo` para `numero_voo`.
    
```{r}
voos %>%
  rename(numero_voo = voo) %>%
  select(companhia_aerea, numero_voo)
```

## Resumindo os dados

Por fim, a serem combinados com as transformações, existem os verbos `group_by()` e `summarise()` que ajudam a resumir o conjunto de dados em linhas menores. Aqui o que cada um faz:

### `summarise()`

É capaz de calcular resumos estatísticos de uma tabela com a medida de sua escolha. Por exemplo, aqui conseguimos saber a mediana da distância entre os aeroportos nos voos do nosso conjunto de dados.

```{r}
voos %>% 
  summarise(
    mediana_distancia = median(distancia),
    atraso_saida = median(atraso_saida, na.rm = T)) %>% 
  mutate(mediana_distancia_km = mediana_distancia*1.609)
```
Em média, os voos deste conjunto percorrem 872 milhas, ou seja, 1.400 km, entre aeroportos.

### `group_by()`

Mais poderoso quando combinado com o `summarise()`, o `group_by()` cria grupos a partir das colunas especificadas para manipular o conjunto de dados. Ele não modifica a tabela em si, mas combina os resultados de acordo com as operações escritas.

```{r}
voos %>%
  group_by(mes) %>% 
  summarise(distancia_media = mean(distancia),
            atraso_saida = mean(atraso_saida, na.rm = T)) %>% 
  arrange(-atraso_saida)
``` 


Aqui, vamos usar o conjunto `voos_atrasados`, criado a partir do `mutate()`, para identificar os status de horário mais comuns no nosso conjunto de dados.


```{r}
voos_atrasados %>%
  group_by(status_horario) %>% # agrupando pelo status de horário
  summarise(n = n(), # o número de linhas em cada grupo
            mean_distancia = mean(distancia)) %>% 
  ungroup() %>% 
  mutate(p = n /sum(n))
``` 

Ou seja, vemos que é mais comum os voos chegarem antes do horário programado do que depois. E poucos chegam exatamente no horário previsto.




# Alcançando a estrutura tidy com o tidyr

Com os principais verbos do `dplyr` na manga, agora é hora de explorar o `tidyr` que, lembrando, serve para transformar o conjunto de dados. 

Isso significa fazer os ajustes necessários para garantir que os dados estejam organizados de uma forma `tidy`, que baseia toda a lógica do `tidyverse`. Lembrando que a filosofia `tidy` é uma forma de vincular a estrutura de um conjunto de dados (seu layout físico) com sua semântica (seu significado). E para tal, os dados precisam ser organizados garantindo que:

- cada variável/informação tenha a sua própria coluna;
- cada observação/unidade de análise tenha a sua própria linha; e
- que cada valor tenha a sua própria célula.

A biblioteca `tidyr` tem o propósito de ajudar neste processo, caso o conjunto de dados ainda não esteja neste formato.

## Reformatando os dados (pivotagem)

### De linhas para colunas: `pivot_wider()`

Como o nome descreve, o `pivot_wider()` "gira" o eixo dos dados para o formato largo – em detrimento de um formato comprido. Um exemplo simples:


```{r}
fish_encounters

fish_encounters %>% 
  pivot_wider(names_from = station, values_from = seen)
```


```{r}
us_rent_income

us_rent_income %>%
  pivot_wider(names_from = variable,
              values_from = c(estimate, moe))
```


### De colunas para linhas: `pivot_longer()`

Como o inverso da função anterior, o `pivot_longer()` transforma o conjunto de dados em um formato comprido, ou seja, onde o número de linhas aumenta e o de colunas diminui.

Para isso, ele usa as colunas especificadas na coluna parâmetro `cols`, e seus valores na coluna parâmetro `value`. Assim conseguimos tratar os dados como nos exemplos acima, seja filtrando, escrevendo novas variáveis, transformando as já existentes, e mais.

Considere o conjunto `billboard`, que lista os rankings de músicas na Billboard top 100 durante o ano 2000.

```{r}
data("billboard")

billboard %>% head()
```

Como vemos no conjunto `billboard`, as colunas começando com `wk` definem qual a posição da música no ranking a partir da semana que entraram e vai desde o 1 até o 76. No entanto, não é possível rodar a maioria das funções que aprendemos acima porque a informação das semanas está em **colunas** e não em **linhas**.

Para resolver isso, precisamos transformá-la em formato longo, criando a variável `week`. Vamos selecionar todas as colunas que começam com `wk` e os valores atribuídos a elas estarão em uma nova coluna chamada `rank`.

```{r}
billboard_longer <- billboard %>% 
  pivot_longer(cols = starts_with("wk"),
               names_to = "week",
               values_to = "rank",
               values_drop_na = TRUE)

billboard_longer %>% head()
```

Viu? Agora ficou muito mais fácil de analisar. Por exemplo, aqui vemos as faixas que ficaram por mais de 30 semanas no ranking da Billboard, organizada pela média de ranking. A faixa *Higher* apareceu na Billboard por 57 semanas (não consecutivas) e, em média, ficou na posição 36.

```{r}
billboard_longer %>% 
  group_by(track, artist) %>% 
  summarise(n_week = n(), rank_mean = mean(rank)) %>% 
  filter(n_week > 30) %>% 
  arrange(desc(n_week)) 
```

#### voltando para o formato longo:


```{r}
billboard_longer %>%
  pivot_wider(names_from = week, 
              values_from = rank,
              names_prefix = "wk")
```

## Separando e combinando colunas  

Também podemos combinar ou dividir os valores de cada coluna. Como exemplo, vamos voltar para o conjunto de dados de `voos`.

### `separate()`

Esta função divide uma única coluna em várias colunas. Similarmente, a opção `separate_rows()` faz a mesma coisa para linhas.

Por exemplo, no conjunto `voos`, o `horario_saida` é escrito em horário local no formato `HHMM` ou `HMM`, onde `517` indica 5:17 AM. Podemos separá-lo em `horario_saida_h` e `horario_saida_m` para obter o horário e minuto de saída em diferentes colunas.

Para a separação não ficar muito complicada, primeiro vamos pegar os horários com três dígitos, que provalmente o primeiro caractere indica a hora e os dois últimos, os minutos.

```{r}
voos %>%
  filter(nchar(horario_saida) == 3) %>%
  separate(horario_saida,
           into = c("horario_saida_h",
                    "horario_saida_m"),
           sep = 1, remove = FALSE) %>%
  select(ano:horario_saida_m)
```
  
### `unite()` 

De maneira oposta, o `unite()` é capaz de unir colunas a partir de um separador. Por exemplo, podemos criar a coluna `numero_voo` juntando a `companhia_aerea` com o `voo` de forma fácil, separando com o espaço:

```{r}
voos %>%
  unite(companhia_aerea, voo,
        col = "numero_voo",
        sep = " ", remove = FALSE) %>% 
  select(companhia_aerea, voo, numero_voo)
```

# Recursos avançados

Agora, que já aprendemos o essencial do `dplyr` e `tidyr`, podemos nos aprofundar em funções que vão potencializar ainda mais a transformação e arrumação de dados.

## Combinando bases (join/merge)

Uma ação usual para o redirecionamento dos dados diz respeito a necessidade de combinar diferentes bases de dados visando obter uma fonte única, com todas as informações de interesse.

Aqui algumas, mas não todas, possibilidades de combinação:

- `inner_join()`: retorna todas as linhas da base à esquerda que possuem valores correspondentes na base à direita. Se houver várias correspondências entre x e y, todas as combinações das correspondências serão retornadas;
- `left_join()`: retorna todas as linhas de x e todas as colunas de x e y. Linhas em x sem correspondência em y terão valores de NA nas novas colunas. Se houver várias correspondências entre x e y, todas as combinações das correspondências serão retornadas;
- `full_join()`: retorna todas as linhas e todas as colunas de x e y. Onde não há valores correspondentes, retorna NA para o ausente.

Ainda nos dados de `voos` como exemplo, vamos pegar outro conjunto do mesmo pacote chamado `companhias_aereas`. Assim, podemos saber quais são exatamente as companhias aéreas de cada voo registrado no dataset.
    
```{r}
voos_completo <- voos %>%
  left_join(dados::companhias_aereas, by = "companhia_aerea")

voos_completo %>% select(companhia_aerea, voo, nome)
```
Isso possibilita análises mais direcionadas, como a lista das companhias aéreas com o valor máximo de atraso registrado na chegada.

```{r}
voos_completo %>%
  group_by(nome) %>%
  summarise(maior_atraso = max(atraso_chegada, na.rm = TRUE)) %>%
  arrange(desc(maior_atraso))
```

## Lidando com múltiplas colunas (`across()`)

Até aqui, o tidyverse tem como ponto forte a legibilidade do código, se aproximando com a maneira com que pensamos as ações que gostariamos de aplicar nos dados. Nos recursos avançados, nem sempre isso é regra, mas a perda é compensada pela produtividade do código.

Na função `across()`, disponível a partir da versão 1.0 do pacote `dplyr`, é possível aplicar cálculos a multiplas colunas de uma única vez.

Ou seja, em vez de tirar a média de `atraso_saida` e `atraso_chegada` de forma separada, como as duas colunas possuem um padrão, é possível usar o `across()` para operá-las:


```{r}
voos %>% 
    #summarise(across(starts_with("atraso_"), ~mean(.x, na.rm = T)))
    summarise(across(starts_with("atraso_"), mean, na.rm = T))
```

Tem o mesmo resultado de:

```{r}
voos %>%
  summarise(atraso_saida = mean(atraso_saida, na.rm = T),
            atraso_chegada = mean(atraso_chegada, na.rm = T))
```

```{r}
voos %>% 
    #summarise(across(starts_with("atraso_"), ~mean(.x, na.rm = T)))
    summarise(across(where(is.numeric), mean, na.rm = T))
```

Pode parecer algo simples, mas quando você tem:
- muitas colunas que respeitam determinada regra – seja de nomenclatura, tipo de dados, ou qualquer característica que possa ser transcrita segundo um padrão lógico; ou

- variáveis dinâmicas que podem ser adicionadas, alteradas ou removidas do conjunto de dados 

a função `across()` torna-se um recurso extremamente útil para garantir não apenas a eficiência da análise, mas também a replicabilidade do código. 



## Programação funcional (`purrr::`)

Como ferramenta transversal a todas as etapas do workflow de análise, temos a programação funcional, que permite a criação de códigos mais concisos. 

No contexto do `tidyverse`, a biblioteca `purrr` disponibiliza uma série de funcionalidades visando facilitar a aplicação da programação funcional no R. Como principal função temos o `map()`, transformando a sua entrada por meio da aplicação de uma função a cada elemento, e retornando uma lista com o mesmo comprimento que a entrada:

Abaixo, exemplificamos a identificação de quais colunas no conjunto `voos` tem dados faltantes, ou seja, em `NA`:

```{r}
voos %>% 
    map(is.na) %>%
    map(sum) 
```

Visto as bibliotecas que já estudamos, a aplicação da função `is.na()` não se apresenta tão crítica. Contudo é importante lembrar que você pode construir funções no R – conforme apresentado no módulo 1 do curso, inclusive como uma maneira de automatizar uma sequencia de ações – uma função que identifica as observações faltantes e endereça a solução a depender de determinadas características dos dados, por exemplos (comentaremos mais sobre este tipo de situação). De modo que ter os recursos do pacote `purrr` disponíveis, irá garantir que tais ajustes sejam aplicáveis considerando uma semântica mais simples.

Por padrão, o `map()` retorna listas para que o resultado tenha outra estrutura/classe, mas podemos utilizar funções como: `map_dbl` que retorna um vetor numérico, o `map_dfc` para um data.frame que combina os resultados por coluna, entre outras opções. Adicionalmente temos recursos como:

  - `walk()`: similar ao `map`, porém sem ter o retorno da lista no console 
  - `pmap()`: aplica uma função a um grupo de elementos de um grupo de listas
  - `append()`: adiciona valores ao fim de uma lista

Como um último exemplo do poder prático deste pacote, segue um exemplo fictício em que lemos todos os arquivos de extensão `.xlsx` que estão salvos em um mesmo `\diretório` e, na sequência, aplicamos a função `glimpse()` a cada um dos resultados:

```{r, eval=F, warning = F}
#exemplo: para visulizar todos os arquivos de um dado diretório
  list.files("\diretório", pattern='*.xlsx') %>% 
    map(read_excel) %>% 
    walk(glimpse)
```

# Mão na massa!

- Se você estiver trabalhando com uma versão mais recente do RStudio, verá uma aba chamada Tutorial entre os paineis que estão na parte superior, à direita da sua IDE. Nela, você vai encontrar várias opções de manuais interativos, recomendo particularmente: `Filter observations`, `Create new variables` e `Summarise Tables`. Uma última observação: para sair de alguns dos tutoriais você precisa apertar o botão `stop` uma bolinha vermelha que aparece no canto superior esquerdo da própria aba Tutorial ;)

 - Avalie a página [RStudio Cheatsheets](https://www.rstudio.com/resources/cheatsheets/), localize as folhas de dicas relacionadas aos pacotes `dplyr()` e `tidyr()` e observe quais são os textos introdutórios de cada uma das cheatsheets.
 
 - Garantir dados tidy pode ser particularmente desafiador no contexto do Excel, mas o pacote [tidycells](https://r-rudra.github.io/tidycells/) pode te ajudar neste tipo de tarefa.
 
 - Estude os códigos da apresentação do [R Intermediário](Rladies: 
 https://beatrizmilz.github.io/2019-02-R-Interm-R-LadiesSP/#1), feita pelas **R-Ladies São Paulo**.
 
 - Como um caso de uso da função `across()`, a partir do código abaixo, identifique qual o estado com o maior número de casos da `epidWeek` 1 e na `epidWeek` mais recente do histórico.
 
```{r, eval=FALSE}
covid19brazil::brazil_state %>% head() %>% glimpse()

covid19brazil_epidWeek <- covid19brazil::brazil_state %>% 
  group_by(region, state, coduf, epidWeek, population) %>%  
  summarise(across(where(is.integer), ~sum(.))) %>%
  glimpse() 
```
 